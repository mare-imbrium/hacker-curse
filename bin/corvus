#!/usr/bin/env ruby
# ----------------------------------------------------------------------------- #
#         File: corvus
#  Description: navigate tab-separated output, selecting a row and issuing a command
#
#       Author: jkepler  http://github.com/mare-imbrium//jkepler
#         Date: 2014-07-30
#      License: MIT
#  Last update: 2014-08-14 13:19
# ----------------------------------------------------------------------------- #
#  corvus.rb  Copyright (C) 2014 j kepler
#  == TODO
#  - remove junk options like child dirs else program will crash
# - don't save html unless specified, also specify location for tsv's so current not cluttered.
# - config file, save bookmarks and forumlist.
# - remove file stuff
# - how to specify format for single list, and large list.
# - what of comments
require 'readline'
require 'io/wait'
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
require 'fileutils'
require 'yaml'
# -- requires 1.9.3 for io/wait
# -- cannot do with Highline since we need a timeout on wait, not sure if HL can do that

## INSTALLATION
# copy into PATH
# alias c=~/bin/corvus.rb
# c
VERSION="0.0.2"
CONFIG_FILE="~/.corvusinfo"

$bindings = {}
$bindings = {
  "`"   => "main_menu",
  "="   => "toggle_menu",
  "!"   => "command_mode",
  #"@"   => "selection_mode_toggle",
  "M-a" => "select_all",
  "M-A" => "unselect_all",
  "+"   => "add_to_forum_list",
  "-"   => "remove_from_forum_list",
  "<"   => "previous_forum",
  ">"   => "next_forum",
  ":"   => "subcommand",
  "'"   => "goto_bookmark",
  "/"   => "enter_regex",
  "M-p"   => "prev_page",
  "M-n"   => "next_page",
  "SPACE"   => "next_page",
  "M-f"   => "select_visited_files",
  "M-d"   => "select_used_dirs",
  "M-b"   => "select_bookmarks",
  "M-m"   => "create_bookmark",
  "M-M"   => "show_marks",
  "C-c"   => "escape",
  "ESCAPE"   => "escape",
  "TAB"   => "views",
  "C-i"   => "views",
  #"?"   => "dirtree",
  "ENTER"   => "select_current",
  "D"   => "delete_current_forum",
  #"M"   => "forum_actions most",
  "Q"   => "quit_command",
  "RIGHT"   => "column_next",
  "LEFT"   => "column_next 1",
  "C-x"   => "forum_actions",
  "M--"   => "columns_incdec -1",
  "M-+"   => "columns_incdec 1",
  #"S"     =>  "command_file list y ls -lh",
  #"L"     =>  "command_file Page n less",
  "C-d"   =>  "cursor_scroll_dn",
  "C-b"   =>  "cursor_scroll_up",
  "UP"   =>  "cursor_up",
  "DOWN"   =>  "cursor_dn",
  "C-SPACE" => "visual_mode_toggle",

  "M-?"   => "print_help",
  "F1"   => "print_help"
  #"F2"   => "child_dirs",
  #"F3"   => "dirtree",
  #"F4"   => "tree",
  #"S-F1"   => "dirtree",
  #"S-F2"   => "tree"

}

## clean this up a bit, copied from shell program and macro'd 
$kh=Hash.new
$kh["OP"]="F1"
$kh["[A"]="UP"
$kh["[5~"]="PGUP"
$kh['']="ESCAPE"
$kh['[Z']="BACKTAB"
KEY_PGDN="[6~"
KEY_PGUP="[5~"
## I needed to replace the O with a [ for this to work
#  in Vim Home comes as ^[OH whereas on the command line it is correct as ^[[H
KEY_HOME='[H'
KEY_END="[F"
KEY_F1="OP"
KEY_UP="[A"
KEY_DOWN="[B"

$kh[KEY_PGDN]="PgDn"
$kh[KEY_PGUP]="PgUp"
$kh[KEY_HOME]="Home"
$kh[KEY_END]="End"
$kh[KEY_F1]="F1"
$kh[KEY_UP]="UP"
$kh[KEY_DOWN]="DOWN"
KEY_LEFT='[D' 
KEY_RIGHT='[C' 
$kh["OQ"]="F2"
$kh["OR"]="F3"
$kh["OS"]="F4"
$kh[KEY_LEFT] = "LEFT"
$kh[KEY_RIGHT]= "RIGHT"
KEY_F5='[15~'
KEY_F6='[17~'
KEY_F7='[18~'
KEY_F8='[19~'
KEY_F9='[20~'
KEY_F10='[21~'
KEY_S_F1='[1;2P'
$kh[KEY_F5]="F5"
$kh[KEY_F6]="F6"
$kh[KEY_F7]="F7"
$kh[KEY_F8]="F8"
$kh[KEY_F9]="F9"
$kh[KEY_F10]="F10"
# testing out shift+Function. these are the codes my kb generates
$kh[KEY_S_F1]="S-F1"
$kh['[1;2Q']="S-F2"

## get a character from user and return as a string
# Adapted from:
#http://stackoverflow.com/questions/174933/how-to-get-a-single-character-without-pressing-enter/8274275#8274275
# Need to take complex keys and matc against a hash.
def get_char
  begin
    system("stty raw -echo 2>/dev/null") # turn raw input on
    c = nil
    #if $stdin.ready?
      c = $stdin.getc
      cn=c.ord
      return "ENTER" if cn == 13
      return "BACKSPACE" if cn == 127
      return "C-SPACE" if cn == 0
      return "SPACE" if cn == 32
      # next does not seem to work, you need to bind C-i
      return "TAB" if cn == 8
      if cn >= 0 && cn < 27
        x= cn + 96
        return "C-#{x.chr}"
      end
      if c == ''
        buff=c.chr
        while true
          k = nil
          if $stdin.ready?
            k = $stdin.getc
            #puts "got #{k}"
            buff += k.chr
          else
            x=$kh[buff]
            return x if x
            #puts "returning with  #{buff}"
            if buff.size == 2
              ## possibly a meta/alt char
              k = buff[-1]
              return "M-#{k.chr}"
            end
            return buff
          end
        end
      end
    #end
    return c.chr if c
  ensure
    #system "stty -raw echo" # turn raw input off
    system("stty -raw echo 2>/dev/null") # turn raw input on
  end
end

## GLOBALS
#$IDX="123456789abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
#$IDX="abcdefghijklmnopqrstuvwxy"
$IDX=('a'..'y').to_a
$IDX.concat ('za'..'zz').to_a
$IDX.concat ('Za'..'Zz').to_a
$IDX.concat ('ZA'..'ZZ').to_a
$min_index = 1 # this prevents cursor from moving into zeroth position since this is the title.
# using min index as 1 works fine but causes some subtle issues like when there are 2 cols
#  and we press right arrow, then first index is this space.
$min_index = 0 # this is old behavior
$IDX.unshift(" ") if $min_index > 0

#$selected_files = Array.new
$bookmarks = {}
$forumlist = {}
$mode = nil
$glines=%x(tput lines).to_i
$gcols=%x(tput cols).to_i
$grows = $glines - 3
$pagesize = 60
# how many columns we will try to show on one page
$gviscols = 2
$pagesize = $grows * $gviscols
$stact = 0
$editor_mode = true
$enhanced_mode = false
$visual_block_start = nil
$pager_command = {
  :text => 'most',
  :image => 'open',
  :zip => 'tar ztvf %% | most',
  :unknown => 'open'
}
$dir_position = {}
## CONSTANTS
GMARK='*'
DOTMARK='.'
CURMARK='>'
MSCROLL = 10
SPACE=" "
CLEAR      = "\e[0m"
BOLD       = "\e[1m"
BOLD_OFF   = "\e[22m"
RED        = "\e[31m"
ON_RED     = "\e[41m"
GREEN      = "\e[32m"
YELLOW     = "\e[33m"
BLUE       = "\e[1;34m"

ON_BLUE    = "\e[44m"
REVERSE    = "\e[7m"
UNDERLINE    = "\e[4m"
CURSOR_COLOR = ON_BLUE
$patt=nil
$ignorecase = true
$quitting = false
$modified = $writing = false
$visited_files = []
## dir stack for popping
$visited_dirs = []
## dirs where some work has been done, for saving and restoring
$used_dirs = []
$sorto = ""
$viewctr = 0
$history = []
$sta = 0
$cursor = $min_index
$visual_mode = false
# these columns ONLY in long_list_columns is base ONE, like in +cut+.
# These are the columns you want to be shown in a long listing of articles/titles
$long_list_columns = [1,2,3,4]
$long_list_columns = [2,3,4,1]
# sort_columns are zero-based
$sort_columns = [2,3,6]
$column_enum = $sort_columns.cycle
$num_pages = 1
$logger_array = Array.new
# history of commands entered in readline for various prompts or keys
$history = Hash.new
$commandlist = %w[refresh forum_actions view_log clear_log change_file fetch_data_from_net sort_on display_forum next_forum previous_forum new_articles]
$selection_allowed = false
$def_forumlist = %w[ news newest programming ruby python haskell scala java zsh commandline vim vimplugins ]
$cache_path = "."
$hint_message = nil
$hacker_forums =  %w{news newest show jobs ask}
$hints_toggle = true
$yaml_obj = nil
# global

$help = "#{BOLD}M-?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}Q#{BOLD_OFF} Quit "

# Ideally should have only first columns while the others are kept in array
#  so we can get rest of data when needed
def get_data filename=nil
  unless filename
    filename = $filename
  else
    $filename = filename
  end
  raise "File name not found #{filename} in get_data " if !File.exists?(filename)
  #lines = File.open(filename, "r").read.split("\n")
  #if lines.nil? or lines.empty?
    #perror "Failed trying to read #{filename}. Please delete if empty "
    #lines = ["no data", "no data, please refresh"]
  #end
  obj = YAML::load( File.open( filename ) )
  $yaml_obj = obj
  age = compute_file_age filename
  articles = obj[:articles]
  if articles.empty?
    # this happens when doing More with a stale url
    perror "No articles in this file. Please delete file."
    return
  end
  colh = articles.first.keys
  colh = [:title	,:age_text	,:comment_count	,:points	,:article_url	,:comments_url	,:age	,:submitter	,:submitter_url	,:byline]
  $forum_bgcolor = BOLD
  $forum_bgcolor = ON_RED if age > 8
  # this should only happen if columns are in row 0
  # # FIXME
  $column_headings = colh
  $full_data = Array.new
  # there will be a path also at some time
  #$subforum = filename.sub(File.extname(filename),"").sub("__","/")
  $subforum = file_to_forum(filename)
  $host = forum_to_host $subforum
  titles = Array.new
  articles.each do |a|
    titles << a[:title]
    _cols = []
    $column_headings.each do |c|
      _cols << a[c] 
    end
    $full_data << _cols
  end
  perror "No data for #{filename} " if $full_data.empty?
  raise "No data for #{filename} " if $full_data.empty?
  #lines.each_with_index do |l, ix|
    #_cols = l.split("\t")
    #titles << _cols.first
    #$full_data << _cols
  #end
  calc_column_widths
  size_column_headings
  $files = titles
end
def TSV_get_data filename=nil # {{{
  unless filename
    filename = $filename
  else
    $filename = filename
  end
  raise "File name not found #{filename} in get_data " if !File.exists?(filename)
  lines = File.open(filename, "r").read.split("\n")
  if lines.nil? or lines.empty?
    perror "Failed trying to read #{filename}. Please delete if empty "
    lines = ["no data", "no data, please refresh"]
  end
  age = compute_file_age filename
  $forum_bgcolor = BOLD
  $forum_bgcolor = ON_RED if age > 8
  # this should only happen if columns are in row 0
  $column_headings = lines.delete_at(0).split("\t")
  $full_data = Array.new
  # there will be a path also at some time
  #$subforum = filename.sub(File.extname(filename),"").sub("__","/")
  $subforum = file_to_forum(filename)
  $host = forum_to_host $subforum
  titles = Array.new
  lines.each_with_index do |l, ix|
    _cols = l.split("\t")
    titles << _cols.first
    $full_data << _cols
  end
  calc_column_widths
  size_column_headings
  $files = titles
end # }}}
# reload from internet
def fetch_data_from_net subforum=nil, more_url=nil
  unless subforum
    print "Enter name of subforum: "
    subforum = Readline::readline('>', true)
    return if subforum == ""
    $host = forum_to_host subforum
  end
  filename = forum_to_file subforum
  print "fetching for #{subforum} ... saving to #{filename}\n"
  m = nil
  if more_url
    m = "-u #{more_url} "
    m = "-u '" + more_url + "'"
  end
  puts "hacker-yml.rb --pages #{$num_pages} -H #{$host} -s #{subforum} -y #{filename} #{m}"
  # put in begin rescue since sometimes no data, as for programming/rising
  #retval = system("hacker.rb --pages #{$num_pages} #{subforum}")
  retval = system("hacker-yml.rb --pages #{$num_pages} -H #{$host} -s #{subforum} -y #{filename} #{m}")
  status = "#{$?}"
  unless retval
    perror "Error occured in hacker.rb. status is #{status}"
    return
  end

  if File.exists? filename
    get_data filename
    post_cd
  else
    perror "Cannot find file #{filename}. Some error has happened."
  end
  $hint_message = nil
end
# this allows us to fetch more items using the NEXT url
# However, when we read up later, this file will contain a stale next url
# as well as stale date. We should have avoided stale data.
def fetch_more
  more_url = $yaml_obj[:next_url]
  #perror "more url is #{more_url} "
  fetch_data_from_net $subforum, more_url
end
def file_to_forum filename
  forum = File.basename(filename).sub(File.extname(filename),"").sub("__","/")
end
def forum_to_file forum
  file = "#{forum}.yml".sub("/","__")
  file = "#{$cache_path}/#{file}"
end
def forum_to_host fo
  if $hacker_forums.include? fo
    return :hn
  end
  return :rn
end
def reload
  fetch_data_from_net $subforum
end
def calc_column_widths
  $column_widths = []
  row = $full_data.first
  row.each do |r|
    # in some cases like jobs, r may be nil
    #$column_widths << r.strip.size + 1
    # i have padded rjust the integers
    sz = r ? r.size : 1
    $column_widths << sz
  end
end
# truncate column headings to file size of column
def size_column_headings
  $sized_column_headings = []
  if $column_widths
    $column_headings.zip($column_widths) do |h, w| 
      $sized_column_headings << h.slice(0, w)
    end
  end
end

## main loop which calls all other programs
def run(options)
  $browser_mode = options[:browser_mode] || 'text'
  $browser_text = options[:browser_text] || 'links'
  $browser_gui = options[:browser_gui] || 'open'
  $cache_path = options[:cache_path] || "."
  ctr=0
  filename = ARGV[0] || "news.yml"
  config_read
  $open_command = $browser_mode == 'text' ? $browser_text : $browser_gui
  if $bookmarks.empty?
    $bookmarks = { :r => 'ruby', :p => 'programming', :n => 'news', :j => 'java', :c => 'commandline',
                   :v => 'vim', :z => 'zsh', :l => 'linux', :a => 'apple', :h => 'haskell' , :s => 'scala',
                   :u => 'rust', :y => 'python', :w => 'newest' }
  end
  if $forumlist.empty?
    $forumlist = $def_forumlist
  end

  # unfortunately this is insisting on a file being present. It should allow use to fetch data if 
  #  no file.
  unless File.exists? filename
    forum = choose_forum
    if forum
      # fetch data from file, or if not present then internet
      display_forum forum
      filename = data_cached_for forum
    else
      raise "Cannot continue without a forum name"
    end
  end
  $filename = filename
  get_data filename

  fl=$files.size

  selectedix = nil
  $patt=""
  $sta = 0
  while true
    i = 0
    if $patt
      if $ignorecase
        $view = $files.grep(/#{$patt}/i)
      else
        $view = $files.grep(/#{$patt}/)
      end
    else 
      $view = $files
    end
    fl=$view.size
    $sta = 0 if $sta >= fl || $sta < 0
    $viewport = $view[$sta, $pagesize]
    fin = $sta + $viewport.size
    $title ||= $subforum
    $details ||= "-"
    system("clear")
    # title
    # DETAIL LINE
    # on the top line, lets show some details for the line under the cursor (focussed line)
    if true
        fullrow = $viewport[$cursor]
        # in case of long listings cursor can go one higher than size, as we do not scroll.
        if fullrow
          fullrow = get_full_row(fullrow)
          # this is the byline, we shouldmake it the last column
          $details = "#{YELLOW} >> #{fullrow.last} "
        end
    end
    ## HELP LINE
    _hint = ""
    if $hints_toggle
      _hint = $hint_message || get_hint
      _hint = "#{BOLD}#{_hint}#{CLEAR}"
    end
    print "#{GREEN}#{$help}  #{BLUE}corvus #{VERSION}#{CLEAR} : #{_hint}\n"
    #t = "#{$title}  #{$sta + 1} to #{fin} of #{fl}  #{$sorto} F:#{$filterstr}"
    t = "#{$title}#{CLEAR}  #{BOLD}#{$sta + 1} to #{fin} of #{fl} o:#{$sorto}:#{$details} "
    t = t[t.size-$gcols..-1] if t.size >= $gcols
    ## TITLE LINE
    #print "#{BOLD}#{t}#{CLEAR}\n"
    print "#{$forum_bgcolor}#{t}#{CLEAR}\n"
    if $long_listing
      # lets see if we can print the headings
      if $column_headings
        s = get_long_list $sized_column_headings
        print "   ", s, "\n"
      end
    end
    ## nilling the title means a superimposed one gets cleared.
    #$title = nil
    # split into 2 procedures so columnate can e clean and reused.
    buff = format $viewport
    buff = columnate buff, $grows
    # needed the next line to see how much extra we were going in padding
    #buff.each {|line| print "#{REVERSE}#{line}#{CLEAR}\n" }
    buff.each {|line| print line, "\n"  }
    print
    # prompt
    #print "#{$files.size}, #{view.size} sta=#{sta} (#{patt}): "
    _mm = ""
    _mm = "[#{$mode}] " if $mode
    print "\r #{_mm}#{$patt} >"
    ch = get_char
    #puts
    #break if ch == "q"
    #elsif  ch =~ /^[1-9a-zA-Z]$/
    if  ch =~ /^[a-zZ]$/
      # hint mode
      select_hint $viewport, ch
      ctr = 0
    elsif ch == "BACKSPACE"
      if $patt && $patt.size > 0
        $patt = $patt[0..-2]
      end
      ctr = 0
    else
      #binding = $bindings[ch]
      x = $bindings[ch]
      x = x.split if x
      if x
        binding = x.shift
        args = x
        send(binding, *args) if binding
      else
        log "No binding for #{ch}, #{ch.ord} "
      end
      #p ch
    end
    break if $quitting
  end
  puts "bye"
  config_write if $writing
end
def exec_string x=nil
  unless x
    x = Readline::readline(': ')
    return if x.nil? or x == ""
  end

  x = x.split 
  if x
    binding = x.shift
    args = x
    send(binding, *args) if binding
  end
end

## 
#
# print in columns
# ary - array of data
# sz  - lines in one column
#
def columnate ary, sz
  buff=Array.new
  return buff if ary.nil? || ary.size == 0
  
  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  wid = 30
  ars = ary.size
  ars = [$pagesize, ary.size].min
  d = 0
  if ars <= sz
    wid = $gcols - d
  else
    tmp = (ars * 1.000/ sz).ceil
    wid = $gcols / tmp - d
  end
  #elsif ars < sz * 2
    #wid = $gcols/2 - d
  #elsif ars < sz * 3
    #wid = $gcols/3 - d
  #else
    #wid = $gcols/$gviscols - d
  #end

  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix=0
  while true
    ## ctr refers to the index in the column
    ctr=0
    while ctr < sz

      f = ary[ix]
      fsz = f.size
      if fsz > wid
        f = f[0, wid-2]+"$ "
        ## we do the coloring after trunc so ANSI escpe seq does not get get
        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
        end
      else
        ## we do the coloring before padding so the entire line does not get padded, only file name
        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
        end
        #f = f.ljust(wid)
        f << " " * (wid-fsz)
      end

      if buff[ctr]
        buff[ctr] += f
      else
        buff[ctr] = f
      end

      ctr+=1
      ix+=1
      break if ix >= ary.size
    end
    break if ix >= ary.size
  end
  return buff
end
## formats the data with number, mark and details 
def format ary
  #buff = Array.new
  buff = Array.new(ary.size)
  return buff if ary.nil? || ary.size == 0

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix=0
  ctr=0
  pad = false
  pad = true if ary.size > 25
  ary.each do |f|
    ## ctr refers to the index in the column
    ind = get_shortcut(ix)
    ind = ind.ljust(2) if pad
    mark=SPACE
    cur=SPACE
    cur = CURMARK if ix + $sta == $cursor
    #mark=GMARK if $selected_files.index(ary[ix])
    # we are not doing selection here
    #  but maybe today's articles can be starred
    age_in_hours =  article_age_in_hours(f) 
    mark=DOTMARK if age_in_hours < 24
    mark=GMARK if age_in_hours < 8

    if $long_listing
      begin
        f = get_long_list f
      rescue Exception => e
        #f = "%10s  %s  %s" % ["?", "??????????", f]
      end
    end

    s = "#{ind}#{mark}#{cur}#{f}"
    # I cannot color the current line since format does the chopping
    # so not only does the next lines alignment get skeweed, but also if the line is truncated
    # then the color overflows.
    #if ix + $sta == $cursor
      #s = "#{RED}#{s}#{CLEAR}"
    #end

    buff[ctr] = s

    ctr+=1
    ix+=1
  end
  return buff
end
## select file based on key pressed
def select_hint view, ch
  # a to y is direct
  # if x or z take a key IF there are those many
  #
  ix = get_index(ch, view.size)
  if ix
    f = view[ix]
    return unless f
    $cursor = $sta + ix

    if $mode == 'SEL'
      toggle_select f
    elsif $mode == 'COM'
      run_command f
    elsif $mode == "forum"
      display_forum f
    else
      on_enter f
    end
    #selectedix=ix
  end
end
## toggle selection state of file
def toggle_select f
  return unless $selection_allowed
  if $selected_files.index f
    $selected_files.delete f
  else
    $selected_files.push f
  end
end
# returns full row of data for given title
def get_full_row title=nil
  title = get_current_title unless title
  location = $files.index(title)
  raise "no location for title: #{title}" unless location
  fullrow = $full_data[location]
  return fullrow
end
# returns age in hours of given title
def article_age_in_hours title
  $_time_ ||= Time.now.to_i
  fullrow = get_full_row title
  return 10000 unless fullrow
  age = fullrow[6].to_i
  hours = (($_time_ - age)/3600).to_i
  return hours
end
def pad_or_trunc str, wid
  f = str.dup
  fsz = f.size
  if fsz > wid
    f = f[0, wid-2]+"% "
  else
    f << " " * (wid-fsz)
  end
  return f
end
# returns a formatted string for the title submitted.
#  In the case of columns headings, we send in the columns array ?
def get_long_list title
  case title
  when String
    fullrow = get_full_row title
  when Array
    fullrow = title
  end
  s = ""
  # while spacing remember that we add a space after each column, and the index at the start which is about 3 chars

  #@long_list_column_colors ||= [ BLUE, GREEN, ON_RED, ON_BLUE]
  ctr = 0
  if false
    w3 = (($gcols/6).floor.to_i)-1 # minus 1 since we add space after
    w1 = (($gcols/2).floor.to_i) # title
    col_widths = [w1, w3,w3,w3-4]
    col_widths = [ w3,w3,w3-4, w1]
    fullrow.each_with_index do |e, i|
      if $long_list_columns.include? i+1
        wid = col_widths[ctr] || 10
        #colr = $long_list_column_colors[ctr]
        #ss = "#{colr}#{pad_or_trunc(e, wid)}#{CLEAR}"
        s << pad_or_trunc(e, wid)
        s << " "
        ctr += 1
      end
    end
  end
  $long_list_columns.each do |i|
    e = fullrow[i-1]
    #wid = col_widths[ctr] || 10
    #colr = $long_list_column_colors[ctr]
    #ss = "#{colr}#{pad_or_trunc(e, wid)}#{CLEAR}"
    #s << pad_or_trunc(e, wid)
    s << e
    s << " "
    ctr += 1
  end
  return s
end
## open file or directory
def open_file f, ch = nil
  location = $files.index(f)
  fullrow = $full_data[location]
  ch = column_menu fullrow unless ch
  return if ch.to_i > fullrow.size
  url = fullrow[ch.to_i]
  system "#{$open_command} #{url}"
  return # 2014-07-25 - 22:43 
  return unless f
end
def view_article
  title = get_current_title
  return unless title
  open_file title, 4
end
def view_comments
  title = get_current_title
  return unless title
  open_file title, 5
end
def get_current_title
  title = $view[$cursor] if $view[$cursor]
end
def get_current_rowdata
  f = get_current_title
  location = $files.index(f)
  fullrow = $full_data[location]
end

## run command on given file/s
#   Accepts command from user
#   After putting readline in place of gets, pressing a C-c has a delayed effect. It goes intot
#   exception bloack after executing other commands and still does not do the return !
def run_command f
  return
end

## cd to a dir
def change_dir f, pos=nil
end

## clear sort order and refresh listing, used typically if you are in some view
#  such as visited dirs or files
def escape
  $sorto = nil
  $viewctr = 0
  $title = nil
  #$filterstr = "M"
  #visual_block_clear
  refresh
end

## refresh listing after some change like option change, or toggle
def refresh
  get_data
    #$filterstr ||= "M"
    $patt=nil
    $title = nil
end
#
## unselect all files
def unselect_all
  return unless $selection_allowed
  $selected_files = []
  $visual_mode = nil
end

## select all files
def select_all
  return unless $selection_allowed
  $selected_files = $view.dup
end

## accept dir to goto and change to that ( can be a file too)
def goto_dir
  return
end

## toggle mode to selection or not
#  In selection, pressed hotkey selects a file without opening, one can keep selecting
#  (or deselecting).
#
def selection_mode_toggle
  return unless $selection_allowed
  if $mode == 'SEL'
    # we seem to be coming out of select mode with some files
    if $selected_files.size > 0
      run_command $selected_files
    end
    $mode = nil
  else
    #$selection_mode = !$selection_mode
    $mode = 'SEL'
  end
end
## toggle command mode
def command_mode
  if $mode == 'COM'
    $mode = nil
    return
  end
  $mode = 'COM'
end
def goto_parent_dir
  #change_dir ".."
end
## This actually filters, in zfm it goes to that entry since we have a cursor there
#
def goto_entry_starting_with fc=nil
  unless fc
    print "Entries starting with: "
    fc = get_char
  end
  return if fc.size != 1
  ## this is wrong and duplicates the functionality of /
  #  It shoud go to cursor of item starting with fc
  $patt = "^#{fc}"
end
def goto_bookmark ch=nil
  perror "No bookmarks" if $bookmarks.empty?
  unless ch
    print "Enter bookmark char: "
    ch = get_char
  end
  if ch =~ /^[0-9a-z]$/
    forum = $bookmarks[ch.to_sym]
    display_forum forum if forum
  end
end


## take regex from user, to run on files on screen, user can filter file names
def enter_regex
  print "Enter (regex) pattern: "
  #$patt = gets().chomp
  $patt = Readline::readline('>', true)
  ctr = 0
end
# Ask for a yml file name to display
# NOT USED replaced by choose_filename
def accept_file_name # {{{
  print "Enter filename: "
  values = Dir.glob("*.tsv")
  values.each do |e|
    unless Readline::HISTORY.include? e
      Readline::HISTORY.push(e)
    end
  end
  filename = Readline::readline('>', true)
  if File.extname(filename) == ""
    # if no extension, add tsv
    filename << ".tsv"
  end
  Readline::HISTORY.pop if Readline::HISTORY.include? filename
  # we still get dupes when user selects from history
  return filename
end # }}}
# returns a forum name (that has a file in the cache). 
# returned file name not forum name
def choose_filename
  forums = get_cached_forums
  ch, forum = menu "Select a file", forums
  return forum_to_file(forum)
end
# TODO we can c=>ose these in the ctrlp fashion so i don't have to worry about first letter
def choose_forum_old
  values = get_forum_list
  ch, menu_text = menu "Choose forum: ", values
  forum = menu_text
  display_forum forum if forum
end
# returns list of forums both cached and in forumlist
def get_forum_list
  # this assumes they are on the same dir
  forums = get_cached_forums
  f = $forumlist
  forums.push(*f)
  forums = forums.uniq
  return forums
end
# if cached, fetch data from cache, else fetch from internet
def display_forum forum=nil
  forum = choose_forum unless forum
  return unless forum
  $mode = nil
  fn = data_cached_for forum
  if fn
    change_file fn
  else
    fetch_data_from_net forum
  end
end
# returns a list of cached forums with slashes
# TODO need to take care of the actual location
def get_cached_forums
  #values = Dir.glob("*.yml").map{|a| a.sub(".yml","").gsub("__","/"); }
  values = Dir.entries($cache_path).grep(/\.yml$/).map{|a| a.sub(".yml","").gsub("__","/"); }
end
def next_forum
  f = get_cached_forums.sort
  curr = f.index($subforum) 
  log "no index for #{$subforum} " unless curr
  curr ||= 0
  fo = curr == f.size-1 ? f.first : f[curr + 1]
  display_forum fo

end
def previous_forum
  f = get_cached_forums.sort
  curr = f.index($subforum)
  log "previous_forum: no index for #{$subforum} " unless curr
  curr ||= f.size
  fo = curr == 0 ? f.last : f[curr - 1]
  display_forum fo
end

def add_to_forum_list f=nil
  unless f
    print "Add to forumlist: "
    f = Readline::readline('>', false)
    return if f.nil? or f == ""
  end
  $forumlist << f unless $forumlist.include? f
  log "Added #{f} to forumlist"
end
def delete_current_forum
  remove_from_forum_list $subforum
end
# remove from the forumlist, however if you already have yml files on disk, then they keep getting
#  read up.
def remove_from_forum_list f=nil
  unless f
    print "Remove forum from list: "
    oldhist = Readline::HISTORY
    Readline::HISTORY.clear
    Readline::HISTORY.push(*$forumlist) 
    f = Readline::readline('>', false)
    Readline::HISTORY.clear
    Readline::HISTORY.push(*oldhist)
    if f.nil? or f == "" 
      return
    end
  end
  $forumlist.delete(f)
  log "Removed #{f} from forumlist"
  fn = data_cached_for f
  if fn
    system("mv #{fn} #{fn}.old")
  end
  perror "Removed #{f} from forum list and disk. Press a key."
end

# display forum list in ctrlp fashion, selection by ENTER or cancel with ESCAPE C-c
# returns selected forum (not filename)
def choose_forum
  values = get_forum_list
  sel = ctrlp values
  #return unless sel
  #display_forum sel
  return sel
end
def data_cached_for filename
  f = "#{filename}.yml".gsub("/","__")
  f = "#{$cache_path}/#{f}"
  return f if File.exists? f
  perror "No data cached for #{f} "
  return nil
end
# get data for a cached file
def change_file file=nil
  if file.nil?
    #fn = accept_file_name
    file = choose_filename
    return if file == ""
  end
  check_file_age file
  get_data file
  $filename = file
  post_cd
end
def compute_file_age fn
  s = File.stat(fn.chomp)
  mtime = s.mtime
  now = Time.now
  age = (now - mtime).to_i
  return (age/3600).to_i
end
def check_file_age fn
  age = compute_file_age fn
  log "#{fn} is #{age} hours old"
  if age > 24
    pbold "#{fn} is very old ( #{age}  hours). Please refresh"
  elsif age > 8
    pbold "#{fn} is quite old ( #{age}  hours). Please refresh"
  elsif age > 1
    # display it somewhere
  end
  $hint_message = get_hint
  if age > 1
    $hint_message = "#{ON_RED}#{age} hrs old. `r to refresh.#{CLEAR}"
  end
  return age
end

def next_page
  $sta += $pagesize
end
def prev_page
  $sta -= $pagesize
end
def print_help
  system("clear")
  puts "HELP"
  puts
  puts "To act on a title press 1-9 a-z A-Z "
  #puts "Command Mode: Will prompt for a command to run on a file, after selecting using hotkey"
  #puts "Selection Mode: Each selection adds to selection list (toggles)"
  #puts "                Upon exiting mode, user is prompted for a command to run on selected files"
  puts
  ary = []
  $bindings.each_pair { |k, v| ary.push "#{k.ljust(7)}  =>  #{v}" }
  ary = columnate ary, $grows - 7
  ary.each {|line| print line, "\n"  }
  get_char

end
def show_marks
  puts
  puts "Bookmarks: "
  $bookmarks.each_pair { |k, v| puts "#{k.to_s.ljust(7)}  =>  #{v}" }
  puts
  print "Enter bookmark to goto: "
  ch = get_char
  goto_bookmark(ch) if ch =~ /^[0-9a-z]$/
end
# MENU MAIN -- keep consistent with zfm
def main_menu
  h = { 
    "1" => :view_article,
    "2" => :view_comments,
    :f => :display_forum,
    :v => :view_menu,
    :r => :reload,
    :m => :fetch_more,
    :R => :reddit_options,
    :H => :hacker_options,
    :s => :sort_menu, 
    :C => :config_menu,
    :a => :view_article,
    :c => :view_comments,
    :x => :extras
  }
=begin
    :a => :ack,
    "/" => :ffind,
    :l => :locate,
    :v => :viminfo,
    :z => :z_interface,
    :d => :child_dirs,
    :r => :recent_files,
    :t => :dirtree,
    "4" => :tree,
    :F => :filter_menu,
    :c => :command_menu ,
    :B => :bindkey_ext_command,
    :M => :newdir,
    "%" => :newfile,
=end

  menu "Main Menu", h
end
def hacker_options menu_text=nil
  h = { 
    :n => :news,
    :w => :newest,
    :s => :show,
    :j => :jobs,
    :a => :ask
  }
  # TODO ask article needs host name prepended
  # TODO jobs has no comments, check if nil
  unless menu_text
    ch, menu_text = menu "Hacker Options", h
  end
  if menu_text
    m = menu_text.to_s
    fetch_data_from_net m
  end
end
def reddit_options menu_text=nil
  if $hacker_forums.include? $subforum
    perror "Reddit options invalid inside Hacker News subforum"
    return
  end
  h = { 
    :n => :new,
    :r => :rising,
    :c => :controversial,
    :t => :top,
    :h => :hot
  }
  unless menu_text
    ch, menu_text = menu "Reddit Options for #{$subforum} ", h
  end
  if menu_text
    if menu_text == :hot
      fetch_data_from_net "#{$subforum}"
    else
      m = menu_text.to_s
      s =  "#{$subforum}".sub(/\/.*/, '')
      fetch_data_from_net "#{s}/#{m}"
    end
  end
end
def config_menu
  h = { 
    :i => :increase_number_of_pages,
    :b => :set_browsers,
    :o => :open_command
  }
  ch, menu_text = menu "Configuration Menu", h
  case menu_text
  when :open_command
    print "Enter open command: "
    str = Readline::readline('>', true)
    if str && str != ""
      $open_command = str
    end
  when :increase_number_of_pages
    $num_pages += 1
  end
end
def view_menu
  h = { 
    :a => :view_article,
    :c => :view_comments,
    :l => :view_log
  }
  menu "View Menu", h
end
def set_browsers
  s = gets_with_values "Enter gui browser", ["open"]
  $browser_gui = s if s
  s = gets_with_values "Enter text browser", %w[ elinks links w3m lynx ]
  $browser_text = s if s
end
# dispay a menu with numbering, allowing selection by pressing index
# Take a char, so use alphabets for index, if items more than 9
def menu title, h
  case h
  when Hash
    ; # okay
  when Array
    # convert array to a hash using letters for key
    x = "a"
    hash = Hash.new
    h.each do |e|
      hash[x] = e
      x.succ!
    end
    h = hash
  end
  return unless h

  kmax_length = h.keys.max_by(&:length).length
  vmax_length = h.values.max_by(&:length).length
  puts "#{ON_BLUE}#{title}#{CLEAR}"
  h.each_pair { |k, v| 
    d = get_action_desc(v) || ""
    printf " #{BOLD}%-*s#{CLEAR}  %-*s  #{BOLD}%s#{CLEAR}\n",  kmax_length,k, vmax_length,v, d 
  }
  ch = get_char
  binding = h[ch]
  binding = h[ch.to_sym] unless binding
  if binding
    if respond_to?(binding, true)
      send(binding)
    end
  end
  return ch, binding
end
# todo : use hidden to hide old entries like older than a day or n hours
def toggle_menu menu_text=nil
  unless menu_text
    h = { 
      # :h => :toggle_hidden, 
          :c => :toggle_case, :l => :toggle_long_list , "1" => :toggle_columns, 
          :g => :use_gui_browser, :t => :use_text_browser}
    ch, menu_text = menu "Toggle Menu", h
  end
  case menu_text
  when :toggle_hidden
    $hidden = $hidden ? nil : "D"
    refresh
  when :toggle_case
    #$ignorecase = $ignorecase ? "" : "i"
    $ignorecase = !$ignorecase
    refresh
  when :toggle_columns
    $gviscols = 3 if $gviscols == 1
    $long_listing = false if $gviscols > 1 
    x = $grows * $gviscols
    $pagesize = $pagesize==x ? $grows : x
  when :use_gui_browser
    $open_command = $browser_gui || "open"
  when :use_text_browser 
      $open_command = $browser_text || "elinks"

  when :toggle_long_list
    $long_listing = !$long_listing
    if $long_listing
      $gviscols = 1
      $pagesize = $grows
    else
      x = $grows * $gviscols
      $pagesize = $pagesize==x ? $grows : x
    end
    refresh
  end
end

def column_menu row
  h = {}
  row.each_with_index do |e, i|
    h[$IDX[i]] = e
  end
  ch, menu_text = menu "Columns Menu", h
  return $IDX.index(ch)
end

def sort col=nil
  col = col.to_i if col
  col = $column_enum.next unless col
  $full_data = $full_data.sort_by{|x| -x[col].to_i}
  $files = []
  $full_data.each do |e|
    $files << e.first
  end
  return
end
def sort_age ; sort_menu :age; end
def sort_points ; sort_menu :points; end
def sort_comments ; sort_menu :comments; end
def sort_menu menu_text = nil
  # next line is so user can enter on subcommand
  menu_text = menu_text.to_sym if menu_text.is_a? String

  lo = nil
  unless menu_text
    h = { :a => :age, :c => :comments, :p => :points }
    ch, menu_text = menu "Sort Menu", h
  end
  menu_text = ch unless menu_text
  case menu_text
  when :age, "1"
    sort 6
  when :comments, "2"
    sort 2
  when :points, "3"
    sort 3
  end
  $sorto = menu_text
end
alias :sort_on :sort_menu

def command_menu
  ## 
  #  since these involve full paths, we need more space, like only one column
  #
  ## in these cases, getting back to the earlier dir, back to earlier listing
  # since we've basically overlaid the old listing
  #
  # should be able to sort THIS listing and not rerun command. But for that I'd need to use
  # xargs ls -t etc rather than the zsh sort order. But we can run a filter using |.
  #
  h = { :t => :today, :D => :default_command , :R => :remove_from_list}
  if $editor_mode 
    h[:e] = :pager_mode
  else
    h[:e] = :editor_mode
  end
  ch, menu_text = menu "Command Menu", h
  case menu_text
  when :pager_mode
    $editor_mode = false
    $default_command = ENV['MANPAGER'] || ENV['PAGER']
  when :editor_mode
    $editor_mode = true
    $default_command = nil
  when :ffind
    ffind
  when :locate
    locate
  when :today
    $files = `zsh -c 'print -rl -- *(#{$hidden}Mm0)'`.split("\n")
    $title = "Today's files"
  when :default_command
    print "Selecting a file usually invokes $EDITOR, what command do you want to use repeatedly on selected files: "
    $default_command = gets().chomp
    if $default_command != ""
      print "Second part of command (maybe blank): "
      $default_command2 = gets().chomp
    else
      print "Cleared default command, will default to $EDITOR"
      $default_command2 = nil
      $default_command = nil
    end
  end
end
def extras
  h = { "1" => :one_column, "2" => :multi_column, :c => :columns, :r => :config_read , :w => :config_write}
  ch, menu_text = menu "Extras Menu", h
  case menu_text
  when :one_column
    $pagesize = $grows
  when :multi_column
    #$pagesize = 60
    $pagesize = $grows * $gviscols
  when :columns
    print "How many columns to show: 1-6 [current #{$gviscols}]? "
    ch = get_char
    ch = ch.to_i
    if ch > 0 && ch < 7
      $gviscols = ch.to_i
      $pagesize = $grows * $gviscols
    end
  end
end
def select_used_dirs
  return
  $title = "Used Directories"
  $files = $used_dirs.uniq
end
def select_visited_files
  return
  # not yet a unique list, needs to be unique and have latest pushed to top
  $title = "Visited Files"
  $files = $visited_files.uniq
end
# TODO 
# This shows bookmarks in article view but the marks are the hints not the keys themselves
def select_bookmarks
  # added changes in both select_current and select_hint
  # However, the age mark that is show is still for the earlier shown forum based on outdated full_data
  #   So we need to show age mark based on file datw which means a change in display program !!! At least
  #   clear the array full_data
  $mode = "forum"
  $title = "Bookmarks"
  $files = $bookmarks.values

end

## part copied and changed from change_dir since we don't dir going back on top
#  or we'll be stuck in a cycle
def pop_dir
  return # 2014-07-25 - 22:43 
  # the first time we pop, we need to put the current on stack
  if !$visited_dirs.index(Dir.pwd)
    $visited_dirs.push Dir.pwd
  end
  ## XXX make sure thre is something to pop
  d = $visited_dirs.delete_at 0
  ## XXX make sure the dir exists, cuold have been deleted. can be an error or crash otherwise
  $visited_dirs.push d
  Dir.chdir d
  $filterstr ||= "M"
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  post_cd
end
def post_cd
  $patt=nil
  $sta = 0
  $cursor = $min_index
  $title = nil
  #if $selected_files.size > 0
    #$selected_files = []
  #end
  $visual_block_start = nil
  $stact = 0
  screen_settings

  revert_dir_pos
end
#
## read dirs and files and bookmarks from file
def config_read
  f =  File.expand_path(CONFIG_FILE)
  if File.readable? f
    load f
    # maybe we should check for these existing else crash will happen.
    #$bookmarks.push(*bookmarks) if bookmarks
    log "loaded #{CONFIG_FILE} "
  end
end
def get_env_paths
  files = []
  %w{ GEM_HOME PYTHONHOME}.each do |p|
    d = ENV[p]
    files.push d if d
  end
  %w{ RUBYLIB RUBYPATH GEM_PATH PYTHONPATH }.each do |p|
    d = ENV[p]
    files.concat d.split(":") if d
  end
  return files
end

## save dirs and files and bookmarks to a file
def config_write
  return
  # Putting it in a format that zfm can also read and write
  #f1 =  File.expand_path("~/.zfminfo")
  f1 =  File.expand_path(CONFIG_FILE)
  d = $used_dirs.join ":"
  f = $visited_files.join ":"
  File.open(f1, 'w+') do |f2|  
    # use "\n" for two lines of text  
    f2.puts "DIRS=\"#{d}\""
    f2.puts "FILES=\"#{f}\""
    $bookmarks.each_pair { |k, val| 
      f2.puts "BM_#{k}=\"#{val}\""
      #f2.puts "BOOKMARKS[\"#{k}\"]=\"#{val}\""
    }
  end
  $writing = $modified = false
end

## accept a character to save this dir as a bookmark
def create_bookmark
  print "Enter a to z or 0-9 for bookmark: "
  ch = get_char
  if ch =~ /^[0-9a-z]$/
    $bookmarks[ch.sym] = "#{$subforum}"
    $modified = true
  else
    perror "Bookmark must be lower-case character or number."
  end
end
# currently just send to file-actions till we think of better stuff
def register_command cmd
  $commandlist << cmd
end
def gets_with_history prompt, histkey=nil
  histkey ||= prompt
  print "#{prompt}: "
  oldhist = Readline::HISTORY
  Readline::HISTORY.clear
  values = $history[:histkey]
  Readline::HISTORY.push(*values) 
  command = Readline::readline('>', false)
  Readline::HISTORY.clear
  Readline::HISTORY.push(*oldhist)
  if command and command != ""
    values << command unless values.include? command
    $history[histkey] = values
    return command
  end
  return false 
end
def gets_with_values prompt, values
  print "#{prompt}: "
  oldhist = Readline::HISTORY
  Readline::HISTORY.clear
  Readline::HISTORY.push(*values) 
  command = Readline::readline('>', false)
  Readline::HISTORY.clear
  Readline::HISTORY.push(*oldhist)
  if command and command != ""
    return command
  end
  return nil
end
def subcommand
  print "Enter command: "
  oldhist = Readline::HISTORY
  Readline::HISTORY.clear
  Readline::HISTORY.push(*$commandlist) 
  command = Readline::readline(':', false)
  Readline::HISTORY.push(*oldhist)
  return if command.nil? or command == ""
  command = "fetch_data_from_net #{$subforum}" if command == "r" #or command == "refresh"
  command = "next_forum" if command == "n" 
  command = "previous_forum" if command == "p" 
  if $commandlist.include? command
    send(command)
  end
  if command =~ /^\d+$/
    goto_line command
  end
  exec_string(command) if command.index(" ")

  return
  print "Enter command: "
  begin
    #command = gets().chomp
    command = Readline::readline('>', true)
    return if command == ""
  rescue Exception => ex
    return
  end
  if command == "q"
    if $modified
      print "Do you want to save bookmarks? (y/n): "
      ch = get_char
      if ch == "y"
        $writing = true
        $quitting = true
      elsif ch == "n"
        $quitting = true
        print "Quitting without saving bookmarks"
      else
        perror "No action taken."
      end
    else
      $quitting = true
    end
  elsif command == "wq"
    $quitting = true
    $writing = true
  elsif command == "x"
    $quitting = true
    $writing = true if $modified
  elsif command == "p"
    system "echo $PWD | pbcopy"
    puts "Stored PWD in clipboard (using pbcopy)"
  end
end
def quit_command
  if $modified
    puts "Press w to save bookmarks before quitting " if $modified
    print "Press another q to quit "
    ch = get_char
  else
    $quitting = true
  end
  $quitting = true if ch == "q"
  $quitting = $writing = true if ch == "w"
end

def views
  # switch between long list, single row and multi row
  views=[:toggle_columns , :toggle_long_list, :sort_age, :sort_comments, :sort_points]
  viewlabels=%w[Dirs Newest Accessed Oldest Largest Smallest Reverse Name]
  $sorto = nil
  #$title = viewlabels[$viewctr]
  $viewctr += 1
  $viewctr = 0 if $viewctr > views.size
  option = views[$viewctr] || views.first
  case option
  when :toggle_columns, :toggle_long_list
    toggle_menu option
  else
    send(option)
  end

  return # 2014-07-25 - 22:43 

end
# on pressing ENTER key
def select_current
  ## vp is local there, so i can do $vp[0]
  #open_file $view[$sta] if $view[$sta]
  if $mode == "forum"
    display_forum $view[$cursor]
  else
    on_enter get_current_title
  end
end
def on_enter title
  fullrow = get_full_row(title)
  puts "#{BOLD}#{title}#{CLEAR}"
  puts "#{fullrow[-1]}"
  article = fullrow[4]
  comments = fullrow[5]
  puts " "
  puts "a ) article    #{article}"
  puts "c ) comments   #{comments}"
  print "> "
  ch = get_char
  if ch == "a"
    system "#{$open_command} #{article}"
  elsif ch == "c"
    system "#{$open_command} #{comments}"
  end
end

## create a list of dirs in which some action has happened, for saving
def push_used_dirs d=Dir.pwd
  $used_dirs.index(d) || $used_dirs.push(d)
end
def pbold text
  puts "#{BOLD}#{text}#{BOLD_OFF}"
end
def perror text
  puts "#{RED}#{text}#{CLEAR}"
  get_char
end
def pause text=" Press a key ..."
  print text
  get_char
end
## return shortcut for an index (offset in file array)
# use 2 more arrays to make this faster
#  if z or Z take another key if there are those many in view
#  Also, display ROWS * COLS so now we are not limited to 60.
def get_shortcut ix
  return "<" if ix < $stact
  ix -= $stact
  i = $IDX[ix]
  return i if i
  return "->"
end
## returns the integer offset in view (file array based on a-y za-zz and Za - Zz
# Called when user types a key
#  should we even ask for a second key if there are not enough rows
#  What if we want to also trap z with numbers for other purposes
def get_index key, vsz=999
  i = $IDX.index(key)
  return i+$stact if i
  #sz = $IDX.size
  zch = nil
  if vsz > 25
    if key == "z" || key == "Z"
      print key
      zch = get_char
      print zch
      i = $IDX.index("#{key}#{zch}")
      return i+$stact if i
    end
  end
  return nil
end

## generic external command program
#  prompt is the user friendly text of command such as list for ls, or extract for dtrx, page for less
#  pauseyn is whether to pause after command as in file or ls
#
def command_file prompt, *command
  pauseyn = command.shift
  command = command.join " "
    print "[#{prompt}] Choose a file [#{$view[$cursor]}]: "
    file = ask_hint $view[$cursor]
  #print "#{prompt} :: Enter file shortcut: "
  #file = ask_hint
  perror "Command Cancelled" unless file
  return unless file
  file = File.expand_path(file)
  if File.exists? file
    file = Shellwords.escape(file)
    pbold "#{command} #{file} (#{pauseyn})"
    system "#{command} #{file}"
    pause if pauseyn == "y"
    refresh
  else
    perror "File #{file} not found"
  end
end

## prompt user for file shortcut and return file or nil
#
def ask_hint deflt=nil
  f = nil
  ch = get_char
  if ch == "ENTER" 
    return deflt
  end
  ix = get_index(ch, $viewport.size)
  f = $viewport[ix] if ix
  return f
end

## check screen size and accordingly adjust some variables
#
def screen_settings
  $glines=%x(tput lines).to_i
  $gcols=%x(tput cols).to_i
  $grows = $glines - 3
  $pagesize = 60
  #$gviscols = 3
  $pagesize = $grows * $gviscols
end
## moves column offset so we can reach unindexed columns or entries
# 0 forward and any other back/prev
def column_next dir=0
  if dir == 0
    $stact += $grows
    $stact = 0 if $stact >= $viewport.size
  else
    $stact -= $grows
    $stact = 0 if $stact < 0
  end
end
# currently i am only passing the action in from the list there as a key
# I should be able to pass in new actions that are external commands
# c-x CX cx 
def forum_actions 
  h = { :r => :reload, 
        :n => :new_forum, 
        :b => :display_forum, 
        'C-b' => :change_subforum, 
        :N => :new_articles , 
        :k => :delete_current_forum,
        :RIGHT => :next_forum,
        :LEFT => :previous_forum,
        :l => :view_log,
        :C  => :config_menu,
        'C-c' => :quit_app}

  ch, menu_text = menu "Forum Menu ", h
  menu_text = :quit if ch == "q"
  return unless menu_text
  case menu_text.to_sym
  when :quit
  when :reload
    fetch_data_from_net $subforum
  when :pages
    $num_pages += 1
  when :new_articles
    new_articles
  when :new_forum
    fetch_data_from_net
  when :change_subforum
    change_file
  when :quit_app
    quit_command
  when :view_log
    view_log
  when :open_command
    print "Enter open command: "
    str = Readline::readline('>', true)
    if str && str != ""
      $open_command = str
    end
  end
end
def new_articles
  case $host
  when :hn
    fetch_data_from_net "newest"
  else
    fetch_data_from_net "#{$subforum}/new"
  end
end

def columns_incdec howmany
  $gviscols += howmany.to_i
  $gviscols = 1 if $gviscols < 1
  $gviscols = 6 if $gviscols > 6
  $pagesize = $grows * $gviscols
end

# bind a key to an external command wich can be then be used for files
def bindkey_ext_command
  print 
  pbold "Bind a capital letter to an external command"
  print "Enter a capital letter to bind: "
  ch = get_char
  return if ch == "Q"
  if ch =~ /^[A-Z]$/
    print "Enter an external command to bind to #{ch}: "
    com = gets().chomp
    if com != ""
      print "Enter prompt for command (blank if same as command): "
      pro = gets().chomp
      pro = com if pro == ""
    end
    print "Pause after output [y/n]: "
    yn = get_char
    $bindings[ch] = "command_file #{pro} #{yn} #{com}"
  end
end


## some cursor movement functions
##
#
def cursor_scroll_dn
  moveto(pos() + MSCROLL)
end
def cursor_scroll_up
  moveto(pos() - MSCROLL)
end
def cursor_dn
  moveto(pos() + 1)
end
def cursor_up
  moveto(pos() - 1)
end
def pos
  $cursor
end

def moveto pos
  orig = $cursor
  $cursor = pos
  #$cursor = [$cursor, $view.size - 1].min
  ## 2014-07-28 - 00:45 trying out viewport instead of view
  #  this prevents cursor going off when we press down arrow on last row esp on multi-page listings
  #  How does that impact the rest of this method, such as visual_mode
  $cursor = [$cursor, $viewport.size - 1].min
  $cursor = [$cursor, $min_index].max
  star = [orig, $cursor].min
  fin = [orig, $cursor].max
  if $visual_mode
    # PWD has to be there in selction
    if $selected_files.index $view[$cursor]
      # this depends on the direction 
      $selected_files = $selected_files - $view[star..fin]
      ## current row remains in selection always.
      $selected_files.push $view[$cursor]
    else
      $selected_files.concat $view[star..fin]
    end
  end
end
def visual_mode_toggle
  $visual_mode = !$visual_mode
  if $visual_mode
    $visual_block_start = $cursor
    $selected_files.push $view[$cursor]
  end
end
def visual_block_clear
  if $visual_block_start
    star = [$visual_block_start, $cursor].min
    fin = [$visual_block_start, $cursor].max
    $selected_files = $selected_files - $view[star..fin]
  end
  $visual_block_start = nil
  $visual_mode = nil
end
def file_starting_with fc
  ix = return_next_match(method(:file_matching?), "^#{fc}")
  if ix
    goto_line ix
  end
end
def file_matching? file, patt
  file =~ /#{patt}/
end

## generic method to take cursor to next position for a given condition
def return_next_match binding, *args
  first = nil
  ix = 0
  $view.each_with_index do |elem,ii|
    if binding.call(elem, *args)
      first ||= ii
      if ii > $cursor 
        ix = ii
        break
      end
    end
  end
  return first if ix == 0
  return ix
end
##
# position cursor on a specific line which could be on a nother page
# therefore calculate the correct start offset of the display also.
def goto_line pos
  pos = pos.to_i
  pages = ((pos * 1.00)/$pagesize).ceil
  pages -= 1
  $sta = pages * $pagesize + 1
  $cursor = pos
end
def filetype f
  return nil unless f
  f = Shellwords.escape(f)
  s = `file #{f}`
  if s.index "text"
    return :text
  elsif s.index(/[Zz]ip/)
    return :zip
  elsif s.index("archive")
    return :zip
  elsif s.index "image"
    return :image
  elsif s.index "data"
    return :text
  end
  nil
end

def save_dir_pos 
  return if $sta == $min_index && $cursor == $min_index
  $dir_position[Dir.pwd] = [$sta, $cursor]
end
def revert_dir_pos
  $sta = 0
  $cursor = $min_index
  a = $dir_position[Dir.pwd]
  if a
    $sta = a.first
    $cursor = a[1]
    raise "sta is nil for #{Dir.pwd} : #{$dir_position[Dir.pwd]}" unless $sta
    raise "cursor is nil" unless $cursor
  end
end
def newdir
  print 
  print "Enter directory name: "
  str = Readline::readline('>', true)
  return if str == ""
  if File.exists? str
    perror "#{str} exists."
    return
  end
  begin
    FileUtils.mkdir str
    $used_dirs.insert(0, str) if File.exists?(str)
    refresh
  rescue Exception => ex
    perror "Error in newdir: #{ex}"
  end
end
def newfile
  print 
  print "Enter file name: "
  str = Readline::readline('>', true)
  return if str == ""
  system "$EDITOR #{str}"
  $visited_files.insert(0, str) if File.exists?(str)
  refresh
end

##
# Editing of the User Dir List. 
# remove current entry from used dirs list, since we may not want some entries being there
#

def remove_from_list
  return unless $selection_allowed
  if $selected_files.size > 0
    sz = $selected_files.size
    print "Remove #{sz} files from used list (y)?: "
    ch = get_char
    return if ch != "y"
    $used_dirs = $used_dirs - $selected_files
    $visited_files = $visited_files - $selected_files
    unselect_all
    $modified = true
    return
  end
  print
  ## what if selected some rows
  file = $view[$cursor]
  print "Remove #{file} from used list (y)?: "
  ch = get_char
  return if ch != "y"
  file = File.expand_path(file)
  if File.directory? file
    $used_dirs.delete(file)
  else
    $visited_files.delete(file)
  end
  refresh
  $modified = true
end
#
# If there's a short file list, take recently mod and accessed folders and put latest
# files from there and insert it here. I take both since recent mod can be binaries / object
# files and gems created by a process, and not actually edited files. Recent accessed gives
# latest source, but in some cases even this can be misleading since running a program accesses
# include files.
def enhance_file_list
  return
  return unless $enhanced_mode
  # if only one entry and its a dir
  # get its children and maybe the recent mod files a few
  
  if $files.size == 1
    # its a dir, let give the next level at least
    if $files.first[-1] == "/"
      d = $files.first
      f = `zsh -c 'print -rl -- #{d}*(omM)'`.split("\n")
      if f && f.size > 0
        $files.concat f
        $files.concat get_important_files(d)
        return
      end
    else
      # just a file, not dirs here
      return
    end
  end
  # 
  # check if a ruby project dir, although it could be a backup file too,
  # if so , expand lib and maby bin, put a couple recent files
  #
  if $files.index("Gemfile") || $files.grep(/\.gemspec/).size > 0
    # usually the lib dir has only one file and one dir
    flg = false
    $files.concat get_important_files(Dir.pwd)
    if $files.index("lib/")
      f = `zsh -c 'print -rl -- lib/*(om[1,5]M)'`.split("\n")
      if f && f.size() > 0
        insert_into_list("lib/", f)
        flg = true
      end
      dd = File.basename(Dir.pwd)
      if f.index("lib/#{dd}/")
        f = `zsh -c 'print -rl -- lib/#{dd}/*(om[1,5]M)'`.split("\n")
        if f && f.size() > 0
          insert_into_list("lib/#{dd}/", f)
          flg = true
        end
      end
    end
    if $files.index("bin/")
      f = `zsh -c 'print -rl -- bin/*(om[1,5]M)'`.split("\n")
      insert_into_list("bin/", f) if f && f.size() > 0
      flg = true
    end
    return if flg

    # lib has a dir in it with the gem name

  end
  return if $files.size > 15

  ## first check accessed else modified will change accessed
  moda = `zsh -c 'print -rn -- *(/oa[1]M)'`
  if moda && moda != ""
    modf = `zsh -c 'print -rn -- #{moda}*(oa[1]M)'`
    if modf && modf != ""
      insert_into_list moda, modf
    end
    modm = `zsh -c 'print -rn -- #{moda}*(om[1]M)'`
    if modm && modm != "" && modm != modf
      insert_into_list moda, modm
    end
  end
  ## get last modified dir
  modm = `zsh -c 'print -rn -- *(/om[1]M)'`
  if modm != moda
    modmf = `zsh -c 'print -rn -- #{modm}*(oa[1]M)'`
    insert_into_list modm, modmf
    modmf1 = `zsh -c 'print -rn -- #{modm}*(om[1]M)'`
    insert_into_list(modm, modmf1) if modmf1 != modmf
  else
    # if both are same then our options get reduced so we need to get something more
    # If you access the latest mod dir, then come back you get only one, since mod and accessed
    # are the same dir, so we need to find the second modified dir
  end
end

# log messages that may not remain on the screen by user may wish to see
#  such as age of current file being displayed.
def log str
  $logger_array.unshift str
end
def view_log
  page_data $logger_array
end
def clear_log
  $logger_array.clear
end
def page_data array
  require 'tempfile'
  f = Tempfile.new("corvuslog")
  begin
    path = f.path
    array.each do |line|
      f.puts line
    end
    f.close
    system("less #{path}")
  ensure
    f.close
    f.unlink
  end
end
# allows user to select from list, returning string if user pressed ENTER
#  Aborts if user presses Q or C-c or ESCAPE
def ctrlp arr
  patt = nil
  curr = 0
  while true
    system("clear")
    if patt and patt != ""
      # need fuzzy match here
      view = arr.grep(/^#{patt}/)
      view = view | arr.grep(/#{patt}/)
      fuzzypatt = patt.split("").join(".*")
      view = view | arr.grep(/#{fuzzypatt}/)
    else
      view = arr
    end
    curr = [view.size-1, curr].min
    # if empty then curr becomes -1
    curr = 0 if curr < 0
    view.each_with_index do |a, i|
      mark = " "
      mark = ">" if curr == i
      print "#{mark}  #{a} \n"
    end
    #puts " "
    print "\r#{patt} >"
    ch = get_char
    if  ch =~ /^[a-z]$/
      patt ||= ""
      patt << ch
    elsif ch == "BACKSPACE"
      if patt && patt.size > 0
        patt = patt[0..-2]
      end
    elsif ch == "Q" or ch == "C-c" or ch == "ESCAPE"
      break
    elsif ch == "UP"
      curr -= 1
      curr = 0 if curr < 0
    elsif ch == "DOWN"
      curr += 1
      curr = [view.size-1, curr].min
      # if empty then curr becomes -1
      curr = 0 if curr < 0
    elsif ch == "ENTER"
      return view[curr]
    else
      # do right and left arrow

      # get arrow keys here
    end

  end
end
def get_hint
  if $gviscols == 2 and $view.size > 25
    return "(Toggle) Press =1 to see single column, =l for long listing"
  end
  if $long_listing
    return "(Command) To sort, press :sort_on or `s (backtick s)"
  end
  hints = [
  "(Backtick) Press `1 for article, `2 for comments for current line",
  "(Colon) Press :n<ENTER> for next forum, :p<ENTER> for previous forum",
  "Reload current forum with `r or :r<ENTER>",
  "Get more articles with `m (backtick m)",
  "(Command) Press : and then up arrow to see available commands",
  "Press > for next forum, < for previous forum (less than and greater than keys)",
  "Press TAB to cycle through views"
  ]
  return hints[rand(hints.size)] || hints.last
end
def get_action_desc action
  h = { :reload => "Reload latest articles for this forum", 
        :new_forum => "Get articles for a new forum", 
        :display_forum => "List forums and select one", 
        :change_subforum => "List forums and select one", 
        :new_articles  => "Get latest articles from reddit /new option", 
        :view_menu  => "View options: articles, comments, log", 
        :reddit_options  => "New, rising, controversial, top for this forum", 
        :hacker_options  => "Newest, show, ask, jobs",
        :fetch_more  => "Fetch another page for this forum",
        :delete_current_forum => "Remove forum from your list",
        :next_forum => "Cycle through selected forums",
        :previous_forum => "Cycle through selected forums"
  }
  return h[action] 
end

# http://www.ruby-doc.org/stdlib/libdoc/optparse/rdoc/classes/OptionParser.html
require 'optparse'
options = {}
app = File.basename $0
OptionParser.new do |opts|
  opts.banner = %Q{
#{app} version #{VERSION} (YML version)
Usage: #{app} [options]
}

  #opts.on("-v", "--[no-]verbose", "Print description also") do |v|
    #options[:verbose] = v
  #end
  #opts.on("-n N", "--limit", Integer, "limit to N stories") do |v|
    #options[:number] = v
  #end
  #opts.on("-u URL", String,"--url", "Get articles from URL/file") do |v|
    #options[:url] = v
  #end
  #opts.on("-H (reddit|hn)", String,"--hostname", "Get articles from HOST") do |v|
    #host = v
  #end
  #opts.on("--save-html", "Save html to file?") do |v|
    #options[:save_html] = true
  #end
  #opts.on("-w PATH", String,"--save-html-path", "Save html to file PATH") do |v|
    #options[:htmloutfile] = v
    #options[:save_html] = true
  #end
  opts.on("-m MODE", String,"--mode", "Use 'text' or 'gui' browser") do |v|
    options[:browser_mode] = v
  end
  opts.on("-t browser", String,"--text", "browser for text mode") do |v|
    options[:browser_text] = v
  end
  opts.on("-g browser", String,"--gui", "browser for gui mode") do |v|
    options[:browser_gui] = v
  end
  opts.on("-c cache dir", String,"--cache-dir", "location to store yml files") do |v|
    options[:cache_path] = v
  end
end.parse!
run options
